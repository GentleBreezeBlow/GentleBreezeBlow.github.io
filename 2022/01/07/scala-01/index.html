<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Scala学习, Hexo">
    <meta name="description" content="Scala学习Scala是一种把面向对象和函数式编程理念加入静态类型语言中的混合体。
变量及数据类型变量Scala有两种变量，var和val。val类似于Java中的final变量，一旦初始化了，val就不能再被赋值。相反，var如同Jav">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Scala学习 | Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/16.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Scala学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Scala/">
                                <span class="chip bg-color">Scala</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-07
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Scala学习"><a href="#Scala学习" class="headerlink" title="Scala学习"></a>Scala学习</h1><p>Scala是一种把<strong>面向对象</strong>和<strong>函数式编程</strong>理念加入<strong>静态类型语言</strong>中的混合体。</p>
<h2 id="变量及数据类型"><a href="#变量及数据类型" class="headerlink" title="变量及数据类型"></a>变量及数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Scala有两种变量，var和val。val类似于Java中的final变量，一旦初始化了，val就不能再被赋值。相反，var如同Java中的非final变量，可在它的生命周期中被多次赋值。</p>
<p>变量定义时，必须在变量名前添加关键字<strong>var</strong>或<strong>val</strong>。Scala的变量定义具有覆盖性，也就是说，如果出现了同名的变量，则后出现的变量会覆盖前面的变量。</p>
<p>变量命名不能以数字开头，Scala推荐的命名方法是<strong>驼峰命名法</strong>，即每个单词的首字母大写，并且变量名和函数名以小写字母开头，类、对象和特质则以大写字母开头。例如，<code>val isOne</code>，<code>class MyClass</code>。在首次定义变量时，就<strong>必须赋予具体的值来初始化</strong>。</p>
<p>如果用val定义变量，那么这个变量就不能被重新赋值，但变量指向的对象内部却仍可以改变。也就是说，被指向的对象是唯一的。Chisel中都是用val来定义变量，因为电路的不可变性。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> a <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">)</span>
println<span class="token punctuation">(</span>a<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
A			<span class="token comment">// 打印结果</span>
a<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token char">'a'</span>
println<span class="token punctuation">(</span>a<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
a			<span class="token comment">// 打印结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如例子中定义了一个数组(Array)对象<code>a</code>，而对象<code>a</code>不能被重新赋值成别的数组对象，但是数组内部的元素始终可以被修改。</p>
<blockquote>
<p>Scala提倡定义val类型的变量，因为它是函数式编程，而函数式编程的思想之一就是传入函数的参数不应该被改变。所以，在Scala里，所有函数的参数都必须是val类型的。但是，Scala也允许指令式编程，因而预留了var类型的变量，尽管并不推荐使用。对于习惯了指令式编程的读者，例如，喜欢编写“for(i = 0; i &lt; N; i++)”来实现一个循环，很显然更倾向于使用var类型的变量，因为在这个for循环里，变量i被多次重新赋值。Scala推荐读者学会使用val，学会函数式编程。使用val类型的一个好处就是，你不用去计算某个变量在某个时刻是什么值，因为val类型的变量一旦被初始化，就一直不变，直到被重新定义。</p>
</blockquote>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>在定义变量时，应该指明变量的类型，但Scala的编译器具有<strong>自动推断类型</strong>的功能。显式定义时，在变量名称之后加冒号<code>:</code>及表达式的类型。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> a<span class="token operator">:</span><span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可在字面量结尾添加字母来改变类型，例如整数默认推断为Int，但结尾有L或l，则推断为Long类型。Scala支持字面量前加”0x”表示十六进制，不区分大小写。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> b<span class="token operator">=</span><span class="token number">10L</span>	<span class="token comment">// b: Long = 10</span>
<span class="token keyword">val</span> c<span class="token operator">=</span><span class="token number">0xA</span>	<span class="token comment">// c: Int = 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>字符字面量由单引号’’包裹，Unicode编码。字符串是双引号””包裹，允许转义字符，此外三个双引号””” “””中的内容不会被转义。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> d<span class="token operator">=</span><span class="token char">'\u0041'</span>              	        <span class="token comment">//d: Char = A</span>
<span class="token keyword">val</span> e<span class="token operator">=</span><span class="token triple-quoted-string string">"""So long String \\'\"!"''"""</span>	<span class="token comment">//e: String = So long String \\'\"!"''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Scala是静态语言，在编译期间会检查每个对象的类型。对于类型不匹配的非法操作，在编译时就能被发现。静态语言相比诸如Python这样的动态语言在某些方面是有优势的。对于Chisel而言，我们就需要这种优势。因为Chisel需要编译成Verilog，我们不能产生非法的Verilog语句并且等到模块运行时才去发现它。</p>
<p>Scala标准库定义了一些基本类型，包括Int、Long、Short、Byte、Float、Double、Char及Boolean。除了“String”类型是属于java.lang包之外，其余都在Scala的包里。如，Int的全名是scala.Int。</p>
<p>Scala中的类型<strong>首字母必须大写</strong>，Chisel的UInt等类型，甚至需要两个字母大写。因为Chisel使用的是自定义的数据类型，因此不必过多了解Scala的数据类型。</p>
<h2 id="分号推断"><a href="#分号推断" class="headerlink" title="分号推断"></a>分号推断</h2><p>Scala代码中语句<strong>末尾的分号通常可省略</strong>。愿意也可以加，若一行里仅有一个语句也可以不加。但一行包括多条语句时，分号是必须的：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> println<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可省略分号的前提是一行只有一条语句，且句首和句末不能出现非法结尾字符（例如“.”）。一般来说，按照正常代码风格写就可以省略分号。注意，多条语句时括号要是**花括号{}**，圆括号“()”方括号“[]”无法自动推断分号。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Scala中的函数结构如下，入参要<strong>显式声明类型</strong>，因为编译器在编译期间无法推断入参类型，且<strong>函数入参均为val类型，函数体内不可更改入参</strong>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token string">"def"</span>开始函数定义
  <span class="token operator">|</span> 
  <span class="token operator">|</span> 函数名    
  <span class="token operator">|</span>   <span class="token operator">|</span>      参数列表  函数返回值类型
  <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>         <span class="token operator">|</span>   等号
  <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>         <span class="token operator">|</span>    <span class="token operator">|</span>
  <span class="token keyword">def</span> max<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">></span> y<span class="token punctuation">)</span>
		x
	<span class="token keyword">else</span>  		<span class="token operator">|</span>
		y   	<span class="token operator">|</span>
  <span class="token punctuation">&#125;</span>       		<span class="token operator">|</span>
        		<span class="token operator">|</span>
		花括号中的函数体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有时候Scala编译器需要函数返回值类型的定义。比如如果函数是递归的，那么函数返回值类型就必须明确说明。在上例中，即使不写返回值类型，编译器依旧可以推断。同样，若函数只包含一个语句，花括号亦可省略。这样上例就可以写成：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> max<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">></span> y<span class="token punctuation">)</span> x <span class="token keyword">else</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>默认情况下，编译器会为函数计算结果的最后一个表达式作为函数的返回结果。建议不要显式声明return，这会引发warning，而且使得代码风格看上去像指令式风格。</p>
<p>既不带参数也不返回有用结果的函数定义例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> greet<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> println<span class="token punctuation">(</span><span class="token string">"Hello,world!"</span><span class="token punctuation">)</span>
greet<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">Unit</span>				<span class="token comment">// 解释器返回结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>解释器输出返回<code>greet: ()Unit</code>。greet为函数名，空白的括号说明函数不带参数。Unit是函数的结果类型，指的是函数没有有效的返回值。且Unit是自动推断的，但如果函数显示声明返回值类型为Unit，那么即使函数体最后有一个可返回具体值的表达式，也不会返回结果。Scala的Unit类型比较类似Java的void类型，而且实际上Java里返回void的方法都会被映射为返回Unit的Scala方法。因此结果类型为Unit的方法，并非是为了得到返回值，而是为了其他副作用(side effect)。</p>
<blockquote>
<p>函数定义中有一个等号，这使得它看起来类似数学里的函数“f(x) = …”。当函数的返回值类型没有显式声明时，那么这个等号可以省略，但是返回值类型一定会被推断成Unit类型，不管有没有值返回，而且函数体必须有花括号。当函数的返回值类型显式声明时，则无论如何都不能省略等号。建议写代码时不要省略等号，避免产生不必要的错误，返回值类型最好也显式声明。</p>
</blockquote>
<p>函数体内部还可以嵌套函数，嵌套函数作用域是局部的，只能由函数体内调用，外部无法访问。</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>Scala是<strong>函数式编程语言</strong>。</p>
<blockquote>
<p>函数式编程有两种指导理念，第一种理念是函数是头等值(first-class values)。在函数式语言中，函数也是值，与整数或字符串处于同一地位。函数可以被当作参数传递给其他函数，可以当作结果从函数中返回或保存在变量里。可以在函数里定义其他函数，就好像在函数里定义整数一样。还可以定义匿名函数，并随意地插入到代码的任何地方，就好像使用整数字面量一样。</p>
<p>第二种理念是程序的操作应该把输入值映射为输出值而不是就地修改数据。另一种解释是，方法不应有任何副作用(side effect)。方法与其所在环境交流的唯一方式应该是获得参数和返回结果。</p>
</blockquote>
<p>Scala不强迫使用函数式编程风格，必要情况下，可以写成指令式，用可变数据或有副作用的方法调用。</p>
<blockquote>
<p>函数副作用是指函数在正常工作任务之外对外部环境所施加的影响。例如修改了全局变量的值。</p>
<p>函数的副作用为如果当前函数没有设置参数或设置内部声明变量的var时，当前函数的函数变量就会调用函数的父级作用域的变量，对父级作用域的变量值造成全局污染。</p>
<p>方法(类中定义的函数)没有副作用是函数式风格编程的重要理念，计算并返回值应该是方法唯一的目的。这样做的好处之一是方法之间耦合度降低，因此更加可靠和易于重用；好处之二(在静态类型语言里)是方法的参数和返回值都经过类型检查器的检查，因此可以比较容易地根据类型错误推断其中隐含地逻辑错误。而这种函数式编程思想在面向对象编程中地应用就意味着对象的不可改变性。</p>
</blockquote>
<p>Scala中定义函数字面量形式为：</p>
<pre class="line-numbers language-none"><code class="language-none">(参数1: 参数1类型, 参数2: 参数2类型, ...) &#x3D;&gt; &#123; 函数体 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一般会将函数字面量赋值给一个变量，这样就可通过<code>变量名(参数)</code>的形式来使用函数字面量，例子如下：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span>x <span class="token operator">+</span> y<span class="token punctuation">&#125;</span>
add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>				<span class="token comment">// 返回结果res0: Int = 7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>例子中 <code>(x:Int, y:Int) =&gt; &#123;x + y&#125;</code>相当于定义了一个匿名函数，并且将这个函数赋给了变量 <code>add</code>，因此可以直接用 <code>add(1,6)</code>的形式来使用这个函数。函数字面量形式可以更简单，只保留函数体，而将入参用”_”来代替，例如下面例子同样完成了add功能：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> add <span class="token operator">=</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>				<span class="token comment">// 返回结果res0: Int = 7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>既然函数是一等的值，那么函数体可以把函数字面量作为返回结果，使代码更加简洁。例如下面例子，<code>add(1)(6)</code>第一个括号传给了x，第二个括号传给了y，若没有第二个括号，结果返回的是<code>(y: Int) =&gt; 1 + y</code>这个函数字面量。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span> x <span class="token operator">+</span> y<span class="token punctuation">&#125;</span>
add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>				<span class="token comment">// 返回结果res0: Int = 7</span>
add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>					<span class="token comment">// 返回结果res1: Int => Int = $Lambda$1105/0x00000008006a6840@13cc0b90</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>入参也可以是函数字面量，入参冒号后的写法为<code>(参数1类型，参数2类型，…)=&gt;返回结果的类型</code>。如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> aFun<span class="token punctuation">(</span>f<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
aFun<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span>x<span class="token operator">+</span>y<span class="token punctuation">&#125;</span> <span class="token punctuation">)</span>			<span class="token comment">// 返回结果res0: Int = 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这个例子中，定义了一个名为<code>aFun</code>的函数，它的入参是f函数字面量，该f函数字面量要求有两个Int类型的入参且返回结果类型也是Int。在调用函数<code>aFun</code>时，给出了函数字面量<code>(x,y) =&gt; x+y</code>，因为入参f处已经显式声明类型，因此此处只需给出函数字面量内容即可。这个例子相当于先确定了自变量的值，即x、y为1、2，而将函数具体功能作为了入参，和一般常理解的形式正好相反，例子也说明了函数字面量的灵活以及函数就是和变量等地位相同。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>函数调用默认按参数先后顺序，但也可<strong>显式声明参数名</strong>并赋值。此外，函数入参可以有默认值。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> func<span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">Int</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">,</span> z<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
func<span class="token punctuation">(</span>z<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>函数也可传入<strong>重复参数</strong>，在最后一个参数类型后加上“*”。类型为T*的参数实际类型是<code>Array[T]</code>，即若干个T类型的数组。但传入参数的类型必须是T而不能是数组。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> func<span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">String</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
func<span class="token punctuation">(</span><span class="token string">"Num"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Scala允许柯里化(currying)，即函数可以有任意个参数列表。同时，参数列表里<strong>只有</strong>一个参数时，调用该函数时允许单个参数改用花括号“{}”。注意，花括号只允许单个参数，当参数列表有多个参数时，只能使用括号。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> func<span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>z<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
func<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在阅读代码时，常常遇见诸如 <code>def xxx(f: T =&gt; U, ...) ...</code>或 <code>def xxx(...): T =&gt; U</code>的代码，要理解前者表示需要传入一个函数作为参数，后者表示函数返回的对象是一个函数。</p>
<h2 id="函数式编程风格"><a href="#函数式编程风格" class="headerlink" title="函数式编程风格"></a>函数式编程风格</h2><p>指令式风格，如Java、C++等，我们会更习惯于使用var，但Scala会希望程序中尽量完全使用val。例如下面指令式风格代码：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> printArgs<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        println<span class="token punctuation">(</span>args<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过去掉var的办法将代码变得更函数式风格，例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> printArgs<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>arg <span class="token keyword">&lt;-</span> args<span class="token punctuation">)</span>
    	println<span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>或：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> printArgs<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    args<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>重构后(更函数式)的代码比原来(更指令式)的代码更简洁、明白，更少有机会出错。Scala鼓励函数式风格的原因，实际上也就是因为函数式风格更容易写出易读、不易犯错的代码。</p>
<p>例子中，重构后的<code>printArgs</code>方法并不是纯函数式的，因为它是有副作用——例子的副作用就是打印到标准输出流。识别函数是否有副作用的地方就在于其结果类型是否为Unit。如果返回类型为Unit，那么这个函数唯一能产生的作用就只能是通过某种副作用。</p>
<p>尽可能寻找使用val的机会，它们可让代码既易读又容易重构。</p>
<h2 id="操作符即方法"><a href="#操作符即方法" class="headerlink" title="操作符即方法"></a>操作符即方法</h2><blockquote>
<p>Scala是纯粹的面向对象语言：每个值都是对象，每个操作都是方法调用。</p>
</blockquote>
<p>从技术层面上来说，Scala没有传统意义上的操作符。取而代之的是，诸如+、-、*和/这样的字符，可以用来做方法名。也就是说，<strong>操作符即方法</strong>。例如表达式 <code>1 + 2</code>的真正形式应该是 <code>1.+(2)</code>，实际是在<code>Int</code>对象<code>1</code>上调用名为<code>+</code>的方法，并把<code>2</code>当作参数传给它。</p>
<p>![Scala所有操作符都是方法调用](D:\清风\Study\HexoData\未命名文件 (1).png)</p>
<p>在Java中，int、char等基本类型不属于面向对象的范畴。只能说<code>1</code>是一个int类型的常量，却不能说它是一个int类型的对象。Java还定义了与基本类型相关的操作符，例如“+”，但都不属于面向对象。</p>
<p>Scala追求纯粹的面向对象，Scala标准库里定义了“class Byte”、“class  Short”、“class  Char”、“class Int”、“class  Long”、“class  Float”、“class  Double”、“class  Boolean”和“class Unit”九种值类，只不过这些类是抽象的、不可继承的，因此不能通过<code>new Int</code>这种语句来构造一个Int对象，也不能编写它们的子类，它们的对象都是由字面量来表示。例如，整数字面量<code>1</code>就是一个Int的对象。在运行时，前八种值类会被转换成对应的Java基本类型。第九个Unit类对应Java的<code>void</code>类型，即表示空值，这样就能理解返回值类型为Unit的、有副作用的函数其实是空函数。Unit类的对象由一个空括号作为字面量来表示。</p>
<p>那操作符在Scala中其实是定义在”class Int”、”class Double”等类里的成员方法。</p>
<p>推而广之，<strong>操作符即方法</strong>的概念不仅仅限于九种值类的操作符，Scala里任何类定义的成员方法都是操作符，而且方法调用都能写成操作符的形式：去掉句点符号，并且方法参数只有一个时可以省略圆括号。例如下面例子，例子中 <code>stu.exam(100)</code>和 <code>stu exam 100</code>是等效的。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Students<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> exam<span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> score <span class="token operator">=</span> s
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span>
stu<span class="token punctuation">.</span>exam<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
stu exam <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意：Java中的++i和i++在Scala中不起作用，要想获得同样效果，需写成i=i+1或i+=1。</p>
</blockquote>
<p>符号+是操作符——更明确地说，是<strong>中缀(infix)操作符</strong>。也就是说，调用的方法位于对象和传递给方法的参数或若干参数之间，如<code>7 + 2</code>。Scala还有另外另种操作符标注方式，即前缀标注和后缀标注。前缀标注中，方法名被放在调用的对象之前，如<code>-7</code>里的<code>-</code>。后缀标注中，方法放在对象之后，如<code>7 toLong</code>里的<code>toLong</code>。</p>
<p>与中缀操作符——两个操作数在操作符的左右两侧——相反，前缀和后缀操作符都是一元(unary)的：它们仅有一个操作数。</p>
<p>前缀操作符实际是方法名在操作符字符上前缀<code>unary_</code>。标识符中能作为前缀操作符的只有+、-、!和~。例如<code>-2</code>其实是<code>(2) .unary_-</code>：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token operator">-</span> <span class="token number">2</span>					<span class="token comment">// res0: Int = -2</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>unary_<span class="token operator">-</span>		<span class="token comment">// res1: Int = -2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>后缀操作符是不用点或括号调用的不带任何参数的方法。在Scala里，方法调用的空括号可以省略。惯例是如果方法带有副作用就加上括号，如<code>println()</code>；如果没有副作用就去掉括号，如String的<code>toLowerCase</code>方法：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string">"HELLO!"</span>
s<span class="token punctuation">.</span>toLowerCase		<span class="token comment">// res0: String = hello!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>Scala里以关键词<strong>class</strong>定义类。类里定义的var和val类型变量，称为<strong>字段</strong>；类中定义的函数，称为<strong>方法</strong>，字段和方法统称为成员(member)。对象是类的实例，对象成员可通过<code>对象.成员</code>来访问。与Java不同，Scala类成员<strong>默认公有</strong>，没有关键词<strong>public</strong>，但有关键词<strong>private</strong>修饰表示私有。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Stu<span class="token punctuation">&#123;</span>
	<span class="token keyword">val</span> name<span class="token operator">:</span><span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"None"</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> Stu
println<span class="token punctuation">(</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
None					<span class="token comment">// 打印结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类的构造方法包括主构造方法和辅助构造方法。Scala加强了辅助构造方法调用超类的限制，只允许主构造方法调用超类的构造方法，这让Scala更加简洁。Scala没有指针，同时使用JVM，无需像C++定义析构函数。</p>
<p>Scala为了进一步简化代码，允许在类参数前加上val或var修饰，这样会在类内部生成一个与参数同名的共有字段。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> A<span class="token punctuation">(</span><span class="token keyword">val</span> n<span class="token operator">:</span><span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>…<span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">(</span><span class="token string">"SS"</span><span class="token punctuation">)</span>
println<span class="token punctuation">(</span>a<span class="token punctuation">.</span>n<span class="token punctuation">)</span>
SS						<span class="token comment">// 打印结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单列对象与伴生对象"><a href="#单列对象与伴生对象" class="headerlink" title="单列对象与伴生对象"></a>单列对象与伴生对象</h3><p>相比Java，Scala不能定义静态成员，而是代之以定义<strong>单列对象</strong>(singleton object)。单列对象使用<strong>object</strong>来定义。new实例的对象没有数量限制，而object定义的对象只能有这一个，故得名。</p>
<p>当单例对象和某个类同名时，那么单例对象称为这个类的<strong>伴生对象</strong>(companion object)，同样，类称为这个单例对象的<strong>伴生类</strong>(companion class)。类和它的伴生对象必须定义在一个源文件里，而且他们可以互相访问其私有成员。</p>
<p>Scala追求<strong>纯粹的面向对象</strong>。在Java中，类内部定义的静态变量不属于任何一个用new实例化的对象，而是共有部分。但Scala把类内部的静态变量移除，集中定义在伴生对象里。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">object</span> Test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>定义单列对象并没有定义类型(Scala的抽象层次)。如例子中只有Test对象的定义，就不能建立Test类型的变量。或者可以认为，Test类型是由单列对象的伴生类定义的。然而，单列对象扩展了父类并可以混入特质。因此，可以使用类型调用单列对象的方法，或者用类型的实例变量指代单列对象，并把它传递给需要类型参数的方法。如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Test2
<span class="token keyword">object</span> Test2
<span class="token keyword">val</span> x<span class="token operator">:</span> Test2 <span class="token operator">=</span> Test2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>类和单列对象间的差别是，单列对象不带参数，而类可以。因为单列对象不是用new关键字实例化的，所以没机会传递给它实例化参数。每个单列对象都被实现为虚构类(synthetic class)的实例，并指向静态变量。单列对象在第一次被访问时才会被初始化。</p>
<p>不与伴生类共享名称的单列对象称为独立对象(standalone object)，通常作为打包某方面功能的函数集，或者包含主函数成为程序的入口。</p>
<h3 id="工厂对象和工厂方法"><a href="#工厂对象和工厂方法" class="headerlink" title="工厂对象和工厂方法"></a>工厂对象和工厂方法</h3><p>如果定义一个方法专门用来构造某一个类的对象，那么这种方法就称为<strong>工厂方法</strong>。包含这些工厂方法集合的单例对象，也就叫<strong>工厂对象</strong>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Students<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">object</span> Students <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> registerStu<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span>name<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> stu <span class="token operator">=</span> Students<span class="token punctuation">.</span>registerStu<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子中，工厂对象 <code>Students</code>包含了工厂方法 <code>registerStu</code>。当一系列类存在继承关系时，可以在基类的伴生对象中定义一系列对应的工厂方法。使用工厂方法的好处是不用直接使用new来实例化对象，改用方法调用，而方法名是任意的，这样对外隐藏了类的实现细节。</p>
<p>使用工厂方法可以包含更多重载的方法变体，每一个变体构建一种不同的布局对象。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Students<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> StudentsTwo<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">val</span> subject<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">object</span> Students <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> registerStu<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span>name<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
    <span class="token keyword">def</span> registerStu<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> subject<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> StudentsTwo<span class="token punctuation">(</span>name<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
    <span class="token keyword">def</span> registerStu<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> stuOne <span class="token operator">=</span> Students<span class="token punctuation">.</span>registerStu<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> stuTwo <span class="token operator">=</span> Students<span class="token punctuation">.</span>registerStu<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span><span class="token string">"English"</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> stuThree <span class="token operator">=</span> Students<span class="token punctuation">.</span>registerStu<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子中对象<code>Students</code>包含了三个重载的<code>registerStu</code>方法变体，虽然它们名称相同，但指向不同的实例化对象，从外部来看，使用时可以改变入参数量等，并不需要知道实现细节。</p>
<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>方法中有一个特殊的方法名——<strong>apply</strong>，若是定义了此方法，那么既可以显式调用<code>对象.apply(参数)</code>，也可以隐式调用<code>对象(参数)</code>。当隐式调用时，编译器会自动插入缺失的<code>.apply</code>。若apply是无参方法，应该写出空括号，否则无法隐式调用。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// students.scala</span>
<span class="token keyword">class</span> Students<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> apply<span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> score <span class="token operator">=</span> s
<span class="token punctuation">&#125;</span>

<span class="token keyword">object</span> Students <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> apply<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span>name<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> stu <span class="token operator">=</span> Students<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>	<span class="token comment">// val stu = Students.apply("Tom",100)</span>
stu<span class="token punctuation">.</span>score			<span class="token comment">// res0: Int = 100</span>
stu<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span>
stu<span class="token punctuation">.</span>score			<span class="token comment">// res1: Int = 80</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通常，会在伴生对象里定义apply的工厂方法，这样就能通过<code>伴生对象名(参数)</code>来构造对象，而伴生对象又与伴生类同名，这样代码更加简洁和易读。此外，类里也可定义一个与类相关的、具有特定行为的apply方法，可以隐式调用。例子中<code>val stu = Students(&quot;Tom&quot;,100)</code>实际是<code>val stu = Students.apply(&quot;Tom&quot;,100)</code>，而<code>stu(80)</code>则是隐式调用了类<code>Students</code>中的apply方法。</p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>Scala程序想要独立运行，就必须创建有main方法(仅带一个参数<code>Array[String]</code>，且结果返回类型为<code>Unit</code>)的单列对象。</p>
<p>任何符合条件的单例对象都能成为程序的入口。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// students.scala</span>
<span class="token keyword">class</span> Students<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> apply<span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> score <span class="token operator">=</span> s
<span class="token punctuation">&#125;</span>

<span class="token keyword">object</span> Students <span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> apply<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> score<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">new</span> Students<span class="token punctuation">(</span>name<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// main.scala</span>
<span class="token keyword">object</span> Start <span class="token punctuation">&#123;</span>
    <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        …
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用命令 <code>scalac students.scala main.scala</code>将两个文件编译后，就能用命令 <code>scala Start 参数1 参数2 …</code> 来运行程序。命令里的 <code>Start</code>就是包含主函数的单例对象的名字，后面可以输入若干个用空格间隔的参数。这些参数被打包成字符串数组供主函数使用，也就是args(0)、args(1)、…。</p>
<p>主函数有一种简化写法，就是让单列对象混入<code>App</code>特质，这样就只需在单列对象里编写主函数的函数体。能这么做是因为特质App声明了带有合适签名的main方法，并被该单列对象继承，使它可以像主函数程序那样。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// main.scala</span>
<span class="token keyword">object</span> Start <span class="token keyword">extends</span> App<span class="token punctuation">&#123;</span>
    …
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><blockquote>
<p>在面向对象编程里，类之间两种基本关系：组合和继承。组合指一个类持有另一个的引用，借助被引用的类完成任务。例如，午餐的菜单含有水果，那么就可以先编写一个水果类，然后再编写一个午餐类，并在午餐类里包含水果类的对象，但这两者没有必然联系。继承代表了一种is-a的关系，也就是从一个宽泛的类可以派生出更加具体的类。例如，编写的水果类包含了一些常见水果的公有属性，然后要编写一个更具体的苹果类。</p>
</blockquote>
<p>在类参数列表后加关键词 <code>extends</code>之后加被继承类的类名，即是继承过程。被继承的类称为<strong>超类</strong>或<strong>父类</strong>，而派生出的类称为<strong>子类</strong>。继承层次深，最顶层的类称为<strong>基类</strong>。继承关系只有超类和子类的概念，即超类的超类也叫超类，子类的子类还叫子类。</p>
<p>子类调用超类的构造方法的语法：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> 子类<span class="token punctuation">(</span>子类对外接收的参数<span class="token punctuation">)</span> <span class="token keyword">extends</span> 超类<span class="token punctuation">(</span>子类给超类的参数<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通常，超类的成员都会被子类继承，除了两种成员：一是超类中用 <code>private</code>修饰的私有成员，二是被子类重写的成员。重写超类成员时，需要在定义开头加上关键词 <code>override</code>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> Metal<span class="token punctuation">&#123;</span>
	<span class="token keyword">val</span> state <span class="token operator">=</span> <span class="token string">"solid"</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> Mercury <span class="token keyword">extends</span> Metal<span class="token punctuation">&#123;</span>
	<span class="token keyword">override</span> <span class="token keyword">val</span> state <span class="token operator">=</span> <span class="token string">"liquid"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> mer <span class="token operator">=</span> <span class="token keyword">new</span> Mercury
mer<span class="token punctuation">.</span>state				<span class="token comment">// res0: String = liquid</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果超类成员在开头用关键字 <code>final</code>修饰，那么子类就只能继承，而不能重写。<code>final</code>也可以用于修饰 <code>class</code>，那么这个类就禁止被其他类继承。</p>
<p>Scala允许超类的无参方法被子类重写为字段，但是字段不能反过来被重写为无参方法，而且方法的返回类型必须和字段的类型一致。</p>
<blockquote>
<p>字段与方法的区别在于：字段一旦被初始化之后，就会被保存在内存中，以后每次调用都只需直接读取内存即可；方法不会占用内存空间，但是每次调用都需要执行一遍程序段，速度比字段要慢。</p>
</blockquote>
<p>字段能重写无参方法的原理是Scala只有两种命名空间：①值——字段、方法、包、单例对象；②类型——类、特质。因为字段和方法同处一个命名空间，所以字段可以重写无参方法。同处一个命名空间的定义类型，在同一个作用域内不能以相同的名字同时出现。也就是说<strong>同一个类里不能用相同的名称定义字段和方法</strong>。</p>
<p>类型为超类的变量可以指向子类的对象，这一现象被称为**子类型多态(polymorphism)**，也是面向对象的多态之一。但是对于方法而言，尽管变量的类型是超类，方法的版本却是“动态绑定”的。也就是说，调用的方法要运行哪个版本，是由变量指向的对象来决定的。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> A<span class="token punctuation">&#123;</span>
	<span class="token keyword">def</span> display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"I'm A."</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> B <span class="token keyword">extends</span> A<span class="token punctuation">&#123;</span>
	<span class="token keyword">override</span> <span class="token keyword">def</span> display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"I'm B."</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> x<span class="token operator">:</span>A <span class="token operator">=</span> <span class="token keyword">new</span> B
x<span class="token punctuation">.</span>display				<span class="token comment">// res0:String = I'm B.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子中变量x类型是超类A，但指向的是子类B，因此方法是动态绑定，指向的是子类B中的方法。</p>
<p>如果类里包含了没有具体定义的成员——没有初始化的字段或没有函数体的方法，那么这个类就是<strong>抽象类</strong>，必须用关键字<strong>abstract</strong>修饰。相应的成员称为抽象成员，不需要abstract的修饰。因为存在抽象成员，所以这个类不可能构造出具体的对象，因为有无法初始化抽象字段或者无法执行抽象方法，所以抽象类不能通过“new”来构造实例对象。</p>
<p>抽象类缺失的抽象成员的定义，可以由抽象类的子类来补充。也就是说，抽象类“声明”了抽象成员，却没有立即“定义”它。如果子类补齐了抽象成员的相关定义，就称子类“实现”了超类的抽象成员。相对的，我们称超类的成员是“抽象”的，而子类的成员是“具体”的。子类实现超类的抽象成员时，关键字override可写可不写。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">abstract</span> <span class="token keyword">class</span> A<span class="token punctuation">&#123;</span>
    <span class="token keyword">val</span> a<span class="token operator">:</span><span class="token builtin">Int</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token keyword">new</span> A
<span class="token comment">// error: class A is abstract; cannot be instantiated</span>

<span class="token keyword">class</span> B<span class="token punctuation">(</span><span class="token keyword">val</span> b<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token keyword">extends</span> A<span class="token punctuation">&#123;</span>
    <span class="token keyword">val</span> a <span class="token operator">=</span> b<span class="token operator">*</span><span class="token number">2</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">val</span> y <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
y<span class="token punctuation">.</span>a								<span class="token comment">// res0: Int = 4</span>
y<span class="token punctuation">.</span>b								<span class="token comment">// res1: Int = 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>抽象类常用于定义基类，因为基类会派生出很多不同的子类，这些子类往往具有行为不同的同名成员，所以基类只需要声明有哪些公共成员，让子类去实现它们各自期望的版本。</p>
<p>Scala<strong>没有多重继承</strong>，用特质(Trait)来替代多重继承的功能。</p>
<h3 id="类的层次关系"><a href="#类的层次关系" class="headerlink" title="类的层次关系"></a>类的层次关系</h3><p><img src="https://img-blog.csdnimg.cn/20190208201013172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MjkxNTA1,size_16,color_FFFFFF,t_70" alt="类的层次关系"></p>
<p>最顶部的类是抽象类Any，它是所有类的超类。</p>
<p>再往下一层，Any类有两个子类：<code>AnyVal</code>和<code>AnyRef</code>。也就是说，所有类被分成两大部分：<strong>值类</strong>和<strong>引用类</strong>。值类也就是前面讲过的对应Java的九种基本类型，并且其中七个存在一定的隐式转换，例如Byte可以扩展成Short等等。隐式转换是Scala的一个语法，用于对象在两个类之间进行类型转换，后面章节会讲到。除了标准库里已有的隐式转换，也可以自定义隐式转换。例如标准库中的方法min、max、until、to和abs都定义在类<code>scala.runtime.RichInt</code>里，并且有一个从类<code>Int</code>到<code>RichInt</code>的隐式转换。当调用的方法没有定义在<code>Int</code>中，但定义在<code>RichInt</code>中，就会应用这个隐式转换。</p>
<p>在层次结构的底部有两个底类型——Null类和Nothing类。其中Null类是所有引用类的子类，表示空引用，即指向JVM里的空内存，这与Java的null概念是一样的。但是Null并不兼容值类，所以Scala还有一个类——Nothing，它是所有值类和引用类的子类，甚至还是Null类的子类。因此Nothing不仅表示空引用，还表示空值。Scala里有一个可选值语法，也就是把各种类型打包成一个特殊的可选值。为了表示“空”、“没有”这个特殊的概念，以及兼容各种自定义、非自定义的值和引用类，这个特殊的可选值其实就是把Nothing类进行打包。</p>
<p>自定义的普通类和特质属于引用类。</p>
<p>Chisel中，类继承主要用于编写接口，因为接口可以扩展，但是实际的硬件电路并没有很强烈的继承关系。</p>
<h2 id="特质-Trait"><a href="#特质-Trait" class="headerlink" title="特质(Trait)"></a>特质(Trait)</h2><p>Scala<strong>没有多重继承</strong>，引入新的概念——特质。特质与单例对象很像，两者都不能有入参。但是，单例对象天生就是具体的，特质天生就是抽象的，不过不需要用<code>abstract</code>来说明。特质可以包含抽象成员，而单列对象不行。另外，两者都不能用new来实例化，因为特质是抽象的，而单例对象已经是具体的对象。类、单例对象和特质三者一样，内部可以包含字段和方法，甚至包含其他类、单例对象、特质的定义。</p>
<p>特质可被其他类、单例对象和特质<strong>混入</strong>(mix)。这里使用术语<strong>混入</strong>而不是<strong>继承</strong>(inherit)，是因为特质在超类方法调用上采用线性化机制，与多重继承有很大的区别。</p>
<p>Scala只允许继承自一个类，但是对特质的混入数量却没有限制，故而可用于替代多重继承语法。要混入一个特质，可以使用关键字<code>extends</code>。但如果<code>extends</code>已经被占用了，比如已经拿去继承一个类或混入一个特质，那么后续则通过关键字<code>with</code>来混入其他特质。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">class</span> A
<span class="token keyword">trait</span> B
<span class="token keyword">trait</span> C

<span class="token keyword">object</span> D <span class="token keyword">extends</span> A <span class="token keyword">with</span> B <span class="token keyword">with</span> C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="特质层次"><a href="#特质层次" class="headerlink" title="特质层次"></a>特质层次</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Scala里常见的集合有：数组(Array)、列表(List)、集(Set)、映射(Map)、序列(Seq)、元组(Tuple)、数组缓冲和列表缓冲。</p>
<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>Scala的数组类名为<strong>Array</strong>，继承自Java，Scala中，数组也只是类的实例，可以通过new来构造一个数组对象。</p>
<p>构造数组对象时，首先写方括号和类型参数，然后再写圆括号和值参数，数组对象必须是定长的。语法如下，其中，方括号里的T表示元素的类型，圆括号里的n代表元素个数，它必须是一个非负整数，如果n等于0则表示空数组。Scala的<strong>数组下标从0开始</strong>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">new</span> Array<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Scala的数组是通过索引值加<strong>圆括号</strong>进行的访问，而不是其他语言把索引值放在方括号里。根据操作符即方法的思想，用圆括号传递给变量一个或多个值参数时，Scala会把它转换成对apply方法的调用，该方法接收一个Int类型的参数，返回对应下标的数组元素。所以访问数组的元素也只不过是跟其他一样的方法调用。这个原则不只对于数组：<strong>任何对于对象的值参数应用都将被转换为对apply方法的调用</strong>。前提是这个类型实际定义过apply方法。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> intArray <span class="token operator">=</span> <span class="token keyword">new</span> Array<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
intArray<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
intArray<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>						<span class="token comment">// res0: Int = 1</span>
intArray<span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>				<span class="token comment">// res1: Int = 1</span>

<span class="token keyword">val</span> anyArray <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
anyArray						<span class="token comment">// res2: Array[Any] = (a,b,1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子中的<code>intArray(0)</code>和<code>intArray.apply(0)</code>是等效的。数组内元素可以有不同类型，如例子中的<code>anyArray</code>。<code>anyArray</code>的定义是数组的更简洁定义，编译器可以自动推断数组类型，这实际上是调用了创造并返回新数组的apply工厂方法，apply方法可以有不定个数的参数。</p>
<h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h3><p>列表类名为<strong>List</strong>，这是一个抽象类，因此不能用new来构造列表对象。但是伴生对象里有一个apply工厂方法，接收若干个参数，以数组的形式转换成列表(链表)。</p>
<p>列表是一种基于链表的数据结构，这使得列表访问头部元素很快，往头部增加新元素也是消耗定长时间，但是对尾部进行操作则需要线性化的时间，也就是列表越大时间越长。</p>
<p>列表也是定长的，且每个元素的类型相同、不可再重新赋值，有点像不可写入的数组。列表元素也是从下标0开始索引，下标同样写在圆括号里。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> intList <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>
intList<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>						<span class="token comment">// res0: Int = 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>列表有名为”::”的方法，可以向列表头部添加新元素。注意，这会构造一个新的列表对象，而不是直接修改旧列表，因为<strong>列表是不可变的</strong>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token number">1</span> <span class="token operator">::</span> List<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>					<span class="token comment">// res0: List[Int] = List(1,2,3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>1::List(2,3)</code>中，<code>::</code>是右操作数<code>List(2,3)</code>的方法。如果方法使用操作符来标注，如<code>a*b</code>，那么左操作数是方法的调用者，可以改成<code>a.*(b)</code>。当方法名是以冒号结尾时，方法被右操作数调用。因此，方法“::”的调用者是<code>List(2,3)</code>，可以改写成<code>List(2,3).::(1)</code>，不能写成<code>List(2,3) :: 1</code>，否则编译器会报错。</p>
<p>名为“:::”的方法用于拼接左右两个列表并返回新列表：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span><span class="token operator">:</span> List<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>			<span class="token comment">// res0: List[Int] = List(1,2,2,1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>List有一个子对象——Nil，它表示空列表。Nil的类型是List[Nothing]，List[Nothing]是所有列表的子类，即Nil兼容所有元素。既然Nil是一个空列表对象，那么它同样能调用方法“::”，通过Nil和::就能构造出一个列表，例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token number">1</span> <span class="token operator">::</span> <span class="token number">2</span> <span class="token operator">::</span> <span class="token number">3</span> <span class="token operator">::</span> Nil				<span class="token comment">// res0: List[Int] = List(1,2,3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>用apply工厂方法构造其实是上述方式的等效形式。展开来解释就是：在空列表Nil的头部添加了一个元素3，构成了列表List(3)；随后，继续在头部添加元素2，构成列表List(2, 3)；最后，在头部添加元素1，得到最终的List(1, 2, 3)。</p>
<p>数组与列表元素不仅可以是值类型，它们也可以是自定义的类，甚至是数组和列表本身，构成嵌套的数组与列表。此外，如果元素类型是Any，那么数组和列表也就可以包含不同类型的元素。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">List<span class="token punctuation">(</span>Array<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Array<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// res0: List[Array[Int]] = List(Array(1, 2, 3), Array(10, 100, 100))</span>

List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span>
<span class="token comment">// res1: List[Any] = List(1,1,1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子中的三个1代表类型是不同的，即分别是Int、Char、String类型。</p>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><p>元组是可以包括不同类型的对象的集合，是不可变的。</p>
<p>元组最常用的地方是作为函数的返回值。由于函数只有一个返回语句，但如果想返回多个表达式或对象，就可以把它们包在一个元组里返回。</p>
<p>因为元组含有不同类型的对象，所以不可遍历，也就无法通过下标来索引，只能通过<code>_1</code>、<code>_2</code>……这样来访问每个元素。注意第一个元素就是<code>_1</code>，不是<code>_0</code>。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"God"</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">,</span> <span class="token number">2333</span><span class="token punctuation">)</span>			<span class="token comment">// t:(String,Char,Int) = (God,A,2333)</span>
t<span class="token punctuation">.</span>_1								<span class="token comment">// res0: String = God</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>实际上，元组并不是一个类，而是一系列类：<code>Tuple1</code>、<code>Tuple2</code>、<code>Tuple3</code>……<code>Tuple22</code>。这些类都是具体的，因此除了通过字面量的写法构造元组，也可以显式地通过<code>new TupleX(元组元素)</code>来构造。其中，每个数字代表元组包含的元素数量，也就是说元组最多只能包含22个元素，除非自定义<code>Tuple23</code>、<code>Tuple24</code>……不过这没有意义，因为元组可以嵌套元组，并不妨碍元组包含任意数量的元素。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> getType<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token operator">=</span> x<span class="token punctuation">.</span>getClass
getType<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>							<span class="token comment">// res0: Class[_] = class java.lang.Integer</span>
getType<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'s'</span><span class="token punctuation">,</span><span class="token string">"s"</span><span class="token punctuation">)</span>					<span class="token comment">// res1: Class[_] = class scala.Tuple3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h3><p>顾名思义，映射体现的是一种对应关系，它是一系列“键-值”对的集合，关键词<strong>Map</strong>。键和值的类型可以是任意的，但是每个键-值对的类型必须一致。键-值对的写法是<strong>键 -&gt; 值</strong>。</p>
<p>实际上，<strong>映射并不是一个类，而是一个特质</strong>。所以无法用new构建映射对象，只能通过伴生对象里的apply工厂方法来构造映射类型的对象。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> map <span class="token operator">=</span> Map<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-></span> <span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">-></span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">-></span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-></span> <span class="token string">"/"</span><span class="token punctuation">)</span>

map<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>								<span class="token comment">// res0: String = /</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>表达式<code>object1 -&gt; object2</code>实际就是一个对偶(二元组)，因此键-值对也可以写成对偶的形式。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> tupleMap <span class="token operator">=</span> Map<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 等同于 val tupleMap = Map('a' -> 'A','b' -> 'B')</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="集-Set"><a href="#集-Set" class="headerlink" title="集(Set)"></a>集(Set)</h3><p>集和映射一样，也是<strong>一个特质</strong>，也只能通过apply工厂方法构建对象，关键词<strong>Set</strong>。集只能包含字面值不相同的同类型元素。当构建时传入了重复参数，那么会过滤掉多余的，只取一个。集的apply方法是测试是否包含传入的参数，返回true或false，而不是通过下标来索引元素。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> set <span class="token operator">=</span> Set<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">233</span><span class="token punctuation">)</span>
set<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>							<span class="token comment">// res0: Boolean = false</span>
set<span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">)</span>							<span class="token comment">// res1: Boolean = true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h3><p><strong>map</strong>：map方法接收一个无副作用的函数作为入参，对调用该方法的集合的每个元素应用入参函数，并把所得结果全部打包在一个集合里返回。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">Array<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"pear"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span>
<span class="token comment">// res0: Array[String] = Array(apples, oranges, pears)</span>
List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// res1: List[Int] = List(2,4,6)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>foreach</strong>：foreach方法与map方法类似，不过它的入参是一个有副作用的函数。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>
Set<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">234</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>sum <span class="token operator">+=</span> _<span class="token punctuation">)</span>
sum									<span class="token comment">// res0: Int = 233</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>zip</strong>：zip方法把两个可迭代的集合一一对应，构成若干个对偶。如果其中一个集合比另一个长，则忽略多余的元素。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> zip Array<span class="token punctuation">(</span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">)</span>
<span class="token comment">// res0: List[(Int, Char)] = List((1,1), (2,2), (3,3))</span>
List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> zip Set<span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">,</span> <span class="token string">"OK"</span><span class="token punctuation">)</span>
<span class="token comment">// res1: List[(Int, String)] = List((1,good), (2,OK))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="内建控制结构"><a href="#内建控制结构" class="headerlink" title="内建控制结构"></a>内建控制结构</h2><blockquote>
<p>Scala没有太多的内建控制抽象，它为编写者提供了创建自己的控制抽象的能力。</p>
</blockquote>
<p>Scala内建的控制结构屈指可数，仅有if、while、for、try、match和函数调用而已。少的理由是Scala从语法层面支持函数字面量。</p>
<h3 id="if条件句"><a href="#if条件句" class="headerlink" title="if条件句"></a>if条件句</h3><p>Scala的if语句与其他语言没有什么不同。在if和每个else if后面都将接收一个Boolean类型的表达式作为参数，如果表达式的结果为true，就执行对应的操作，否则跳过。每个分支都可以包含一个表达式作为执行体，如果有多个表达式，则应该放进花括号里。</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>Scala<strong>不提倡使用while</strong>循环语句。while语句风格是指令式(imperative)编程的，在纯函数式的语言里，只有表达式，不会存在像while循环这样的语法。Scala兼容两种风格，并引入了while循环，是因为某些时候用while编写的代码可阅读性更强。</p>
<p>Scala更提倡使用函数式风格来实现功能，因为所有的while循环都可以利用函数递归调用等方法来实现功能。</p>
<p>例如计算整数的最大公约数，指令式风格代码：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> gcdLoop<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> x
    <span class="token keyword">var</span> b <span class="token operator">=</span> y
	<span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">val</span> temp <span class="token operator">=</span> a
        a <span class="token operator">=</span> b <span class="token operator">%</span> a
        b <span class="token operator">=</span> temp
    <span class="token punctuation">&#125;</span>
    b
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数式风格代码：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> gcd<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Long</span> <span class="token operator">=</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token keyword">else</span> gcd<span class="token punctuation">(</span>y<span class="token punctuation">,</span> x <span class="token operator">%</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="for表达式"><a href="#for表达式" class="headerlink" title="for表达式"></a>for表达式</h3><p>实现循环，Scala推荐使用for表达式。</p>
<hr>
<p><strong>枚举集合类</strong>：for能做最简单的事就是把集合中所有元素都枚举一遍。如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> num <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> num<span class="token punctuation">)</span>
	println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>					<span class="token comment">// 将打印5 6 2 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例子中会逐个打印<code>num</code>中的元素，语法<code>i &lt;- num</code>被称为<strong>发生器</strong>(generator)，遍历了数组<code>num</code>的元素。每一次枚举，名为<code>i</code>的新的val就被元素值初始化，编译器推断出<code>i</code>的类型是<code>Int</code>，因为数组<code>num</code>是<code>Array[Int]</code>。对于每一次枚举，for表达式的函数体<code>println(i)</code>就会被执行一次，注意，<code>i</code>打印的结果是被遍历的集合中的元素。</p>
<p>当然，也可以用类似于<code>1 to 5</code>的语法来用for做枚举，for条件中的变量<code>i</code>无需声明，注意操作符<code>&lt;-</code>是一个整体，不要与负号混淆：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> start <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> end <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> start to <span class="token namespace">end</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>					<span class="token comment">// 将打印1 2 3 …… 10</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> start until end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>					<span class="token comment">// 将打印1 2 3 …… 9</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关键字<strong>to</strong>表示循环从<code>start</code>到<code>end</code>。关键字<strong>until</strong>表示循环从<code>start</code>到<code>end-1</code>。</p>
<blockquote>
<p>代码<code>start to end</code>转换为方法调用的写法是<code>(start) .to (end)</code></p>
</blockquote>
<p>其他语言中，当我们想遍历数组可能会这么做：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// Scala中不常见！！！</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">0</span> to <span class="token namespace">num<span class="token punctuation">.</span>length</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	println<span class="token punctuation">(</span>num<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>虽然以上例子在Scala中依旧成立，但不建议采用这种方法。原因是Scala中是集合对象本身可以直接被枚举。这样，代码可以变得更短并规避了许多枚举数组时频繁出现的超位溢出，也不用关心<code>i</code>该从0开始还是1开始，最后的索引值应该加-1还是+1。</p>
<hr>
<p><strong>过滤</strong>：当并不想枚举集合的全部元素，而只想过滤出某个子集，可以在for表达式中添加<strong>过滤器</strong>(filter)，即if子句。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span> <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>					<span class="token comment">// 将打印1 2 4 5 …… 10，没有3</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//等价于</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>				<span class="token comment">// 将打印1 2 4 5 …… 10，没有3</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>过滤器可不止一个，如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span> <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">3</span> <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>					<span class="token comment">// 将打印1 2 4 5 7 8 9 10，没有3 6</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Scala版本在不断更新中，例如2.7.2版本中<del>发生器中加入超过一个过滤器时，if子句必须用分号分隔</del>，但2.13.7版本中已无需分号分隔。3.0.0版本更新又有很大改变，请查看最后一部分内容。</p>
</blockquote>
<hr>
<p><strong>嵌套枚举</strong>：Scala允许使用常见的指令式编程中的嵌套for循环，但也提供更简洁的嵌套循环：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span> <span class="token punctuation">;</span> j <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span><span class="token string">"i:"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//等价于</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        println<span class="token punctuation">(</span><span class="token string">"i:"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> <span class="token string">"j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p><strong>流间(mid-stream)变量绑定</strong>：当for循环条件中重复出现的计算可以通过用等号把结果绑定到新变量实现。绑定的变量被当作val引入和使用，但不必val声明。</p>
<hr>
<p><strong>引入变量</strong>：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">//引入变量</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span> <span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    println<span class="token punctuation">(</span><span class="token string">"j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//等价于</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">-</span> i
    println<span class="token punctuation">(</span><span class="token string">"j:"</span> <span class="token operator">+</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p><strong>制造新集合</strong>：可以创建一个值来记住每一次的迭代，只需在表达式之前加上关键字<strong>yield</strong>。for-yield表达式一般形式如下：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>seq<span class="token punctuation">)</span> <span class="token keyword">yield</span> expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>整个for表达式算一个语句。在这里，seq代表一个序列。换句话说，能放进for表达式里的对象，必须是一个可迭代的集合，比如常用的列表(List)、数组(Array)、映射(Map)、区间(Range)、迭代器(Iterator)、流(Stream)和所有的集(Set)，它们都混入了特质<code>Iterable</code>。当使用花括号包围序列时，分号是可选的。表达式<code>expression</code>在每次执行的时候都会产生一个新值，当表达式完成的时候，结果将是包含了所有产生值得集合对象。对象的类型基于枚举子句处理的集合类型。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">9</span><span class="token punctuation">;</span>j<span class="token keyword">&lt;-</span> i to <span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">yield</span> i<span class="token operator">*</span>j
<span class="token comment">// val res0: IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 6, 8, 10, 12, 14, 16, 18, 9, 12, 15, 18, 21, 24, 27, 16, 20, 24, 28, 32, 36, 25, 30, 35, 40, 45, 36, 42, 48, 54, 49, 56, 63, 64, 72, 81)</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">yield</span> <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token keyword">&lt;-</span> i to <span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">yield</span> i<span class="token operator">*</span>j
<span class="token comment">// val res1: IndexedSeq[IndexedSeq[Int]] = Vector(Vector(1, 2, 3, 4, 5, 6, 7, 8, 9), Vector(4, 6, 8, 10, 12, 14, 16, 18), Vector(9, 12, 15, 18, 21, 24, 27), Vector(16, 20, 24, 28, 32, 36), Vector(25, 30, 35, 40, 45), Vector(36, 42, 48, 54), Vector(49, 56, 63), Vector(64, 72), Vector(81))</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下面例子为例再进行说明for表达式：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// test.scala</span>
<span class="token keyword">class</span> Person<span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>
 
<span class="token keyword">object</span> Alice <span class="token keyword">extends</span> Person<span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">)</span>
<span class="token keyword">object</span> Tom <span class="token keyword">extends</span> Person<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>
<span class="token keyword">object</span> Tony <span class="token keyword">extends</span> Person<span class="token punctuation">(</span><span class="token string">"Tony"</span><span class="token punctuation">)</span>
<span class="token keyword">object</span> Bob <span class="token keyword">extends</span> Person<span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span>
<span class="token keyword">object</span> Todd <span class="token keyword">extends</span> Person<span class="token punctuation">(</span><span class="token string">"Todd"</span><span class="token punctuation">)</span>
 
<span class="token keyword">val</span> persons <span class="token operator">=</span> List<span class="token punctuation">(</span>Alice<span class="token punctuation">,</span> Tom<span class="token punctuation">,</span> Tony<span class="token punctuation">,</span> Bob<span class="token punctuation">,</span> Todd<span class="token punctuation">)</span>
 
<span class="token keyword">val</span> To <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
  p <span class="token keyword">&lt;-</span> persons          		<span class="token comment">// 一个生成器</span>
  n <span class="token operator">=</span> p<span class="token punctuation">.</span>name            		<span class="token comment">// 一个定义，即流间变量绑定</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n startsWith <span class="token string">"To"</span><span class="token punctuation">)</span> 		<span class="token comment">// 一个过滤器</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">yield</span> n
 
println<span class="token punctuation">(</span>To<span class="token punctuation">)</span>						<span class="token comment">// 打印结果：List(Tom,Tony,Todd)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>for表达式中的seq由生成器、定义和过滤器三条语句组成，以分号隔开，或者放在花括号里让编译器自动推断分号。生成器<code>p &lt;- persons</code>的右侧就是一个可迭代的集合对象，把它的每个元素逐一拿出来与左侧的模式进行匹配，匹配的规则来自过滤器。流间变量绑定，即定义，其实就是一个赋值语句，但无需用val声明。这个例子就是遍历集合<code>persons</code>的元素，按顺序找出所有<code>name</code>以<code>To</code>为开头的元素，然后把这些元素组成一个新的集合。</p>
<p>如果只想把每个元素应用到一个Unit类型的表达式，那么就是一个for循环，而不再是一个for表达式。关键字yield也可以省略，就和我们常见的for循环保持一致。</p>
<h3 id="没有continue和break"><a href="#没有continue和break" class="headerlink" title="没有continue和break"></a>没有continue和break</h3><p>对于指令式编程而言，循环里经常用到关键字<code>continue</code>和<code>break</code>，例如下面的Java程序：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Java</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">boolean</span> foundIt <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".scala"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    foundIt <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实际上，这两个关键字对循环而言并不是必须的。例如可以改写成如下Scala代码：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// bad Scala</span>
<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> foundIt <span class="token operator">=</span> <span class="token boolean">false</span>
 
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>foundIt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>args<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>startsWith<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>endsWith<span class="token punctuation">(</span><span class="token string">".scala"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      foundIt <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">&#125;</span>
  i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>又因为这两个关键字过于偏向指令式风格，就像<code>return</code>，所以Scala<strong>并没有引入continue和break</strong>。而且，Scala并不提倡使用循环，可以通过函数的递归调用达到相同的效果。一个更好的、函数式风格的Scala代码如下：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// good Scala</span>
<span class="token keyword">def</span> searchFrom<span class="token punctuation">(</span>i<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>startsWith<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> searchFrom<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>endsWith<span class="token punctuation">(</span><span class="token string">".scala"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i
  <span class="token keyword">else</span> searchFrom<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
 
<span class="token keyword">val</span> i <span class="token operator">=</span> searchFrom<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果实在想用，那么Scala的标准库里提供了break方法。通过<code>import scala.util.control.Breaks._</code>可以导入Breaks类，该类定义了一个名为<code>break</code>的方法。</p>
<h3 id="try表达式处理异常"><a href="#try表达式处理异常" class="headerlink" title="try表达式处理异常"></a>try表达式处理异常</h3><p>Scala的异常和许多其他语言一样。方法除了能以通常的方式返回值以外，还可以通过抛出异常中止执行。方法的调用者要么可以捕获并处理这个异常，或者也可以只是简单地中止掉，并把异常上升到调用者的上一个调用者处。异常以这种方式上升，逐层释放调用堆栈，直到某个方法接手处理或不再剩下其他方法。</p>
<hr>
<p><strong>抛出异常</strong>：抛出异常只需创建一个异常对象然后用关键字<strong>throw</strong>抛出：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> half <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		n<span class="token operator">/</span><span class="token number">2</span>
	<span class="token keyword">else</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> RuntimeException<span class="token punctuation">(</span><span class="token string">"n must be even"</span><span class="token punctuation">)</span>

half<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>			<span class="token comment">// res0: Int = 2</span>
half<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment">// java.lang.RuntimeException: n must be even</span>
<span class="token comment">//   at half(&lt;console>:5)</span>
<span class="token comment">//   ... 32 elided</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段例子意思是如果n是偶数则返回n的一半，如果n不是偶数，那么在half返回任何内容之前将抛出异常。因此，无论怎么说，把抛出的异常当作任何类型的值都是安全的。任何使用经<code>throw</code>返回值的尝试都不会起作用，因此这样做不会有害处。因为抛出的异常的类型是Nothing。虽然<code>throw</code>不实际产生任何值，但还是可以把它当作表达式，这样就会像例子一样，if的一个分支计算值，另一个抛出异常并得出Nothing，整个if表达式的类型就是那个实际计算值的分支的类型。</p>
<hr>
<p><strong>捕获异常</strong>：try后面可以用花括号包含任意条代码，当这些代码产生异常时，并不会立即抛出，而是被catch捕获。catch捕获异常后，按其后面的定义进行相应的处理。</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FileReader
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FileNotFoundException
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException

<span class="token keyword">try</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">val</span> f <span class="token operator">=</span> <span class="token keyword">new</span> FileReader<span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">)</span>
    <span class="token comment">// 使用并关闭文件</span>
<span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> ex<span class="token operator">:</span> FileNotFoundException <span class="token keyword">=></span> <span class="token comment">// 处理丢失的文件</span>
    <span class="token keyword">case</span> ex<span class="token operator">:</span> IOException <span class="token keyword">=></span> <span class="token comment">// 处理其他I/O错误</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本例中，如果异常是<code>FileNotFoundException</code>，那么第一个子句将被执行。如果是<code>IOException</code>类型，第二个子句将被执行。如果都不是，那么try-catch将终结并把异常上升出去。</p>
<hr>
<p><strong>finally子句</strong>：try表达式的完整形式是try-catch-finally。不管有没有异常产生，finally里的代码一定会执行。通常finally语句块都是执行一些清理工作，比如关闭文件。尽管try表达式可以返回有用值，但是最好不要在finally语句块里这么做。因为Java在显式声明return时，会用finally的返回值覆盖前面真正需要的返回值。例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> a<span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token keyword">finally</span> <span class="token keyword">return</span> <span class="token number">2</span>
a			<span class="token comment">// res0: Int = 2</span>

<span class="token keyword">def</span> b<span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token number">1</span> <span class="token keyword">finally</span> <span class="token number">2</span>
b			<span class="token comment">// res1: Int = 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="match表达式"><a href="#match表达式" class="headerlink" title="match表达式"></a>match表达式</h3><p>类似于其他语言的switch语句：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> something<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
  x <span class="token keyword">match</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">case</span> <span class="token string">"Apple"</span> <span class="token keyword">=></span> println<span class="token punctuation">(</span><span class="token string">"Fruit"</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token string">"Tomato"</span> <span class="token keyword">=></span> println<span class="token punctuation">(</span><span class="token string">"Vegetable"</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token string">"Cola"</span> <span class="token keyword">=></span> println<span class="token punctuation">(</span><span class="token string">"Beverage"</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> _ <span class="token keyword">=></span> println<span class="token punctuation">(</span><span class="token string">"Huh?"</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
something<span class="token punctuation">(</span><span class="token string">"Cola"</span><span class="token punctuation">)</span>
<span class="token comment">// 输出：Beverage</span>
something<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>
<span class="token comment">// 输出：Huh?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与Java的switch相比，最显著的差别或许是match表达式也能产生值。如例子中，match表达式的每个备选项不但可以通过打印输出值，还可以只生成返回值而不打印，例如：</p>
<pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token string">"Apple"</span>
<span class="token keyword">val</span> something <span class="token operator">=</span> 
  x <span class="token keyword">match</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">case</span> <span class="token string">"Apple"</span> <span class="token keyword">=></span> <span class="token string">"Fruit"</span>
      <span class="token keyword">case</span> <span class="token string">"Tomato"</span> <span class="token keyword">=></span> <span class="token string">"Vegetable"</span>
      <span class="token keyword">case</span> <span class="token string">"Cola"</span> <span class="token keyword">=></span> <span class="token string">"Beverage"</span>
      <span class="token keyword">case</span> _ <span class="token keyword">=></span> <span class="token string">"Huh?"</span>
  <span class="token punctuation">&#125;</span>
println<span class="token punctuation">(</span>something<span class="token punctuation">)</span>
<span class="token comment">// 打印结果： Fruit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>match表达式生成返回值并储存在<code>something</code>变量里。这除了能让代码变得更简单之外，还解开了两个原本应分离的关注点：首先是选择东西类别，其次才是打印它，这样也避免了使用副作用的函数(第一个例子中的<code>something</code>函数就是副作用的函数)。</p>
<h2 id="Scala-3-0版本更新"><a href="#Scala-3-0版本更新" class="headerlink" title="Scala 3.0版本更新"></a>Scala 3.0版本更新</h2><p>Scala 3.0相比2.12或2.13改动很大，比如增加类型和其他改进，具体请查看<a target="_blank" rel="noopener" href="https://docs.scala-lang.org/scala3/">Scala3官网</a>和<a target="_blank" rel="noopener" href="https://dotty-china.com/">Scala3中文站</a>。此外Scala 3对花括号变为可选语法，利用缩进替代大括号。</p>
<p>因为目前Chisel仍是基于Scala 2，因此这部分暂时无需了解。Chisel官方对Scala 3的态度请看<a target="_blank" rel="noopener" href="https://github.com/chipsalliance/chisel3/issues/2286">github_issues</a>，Chisel对Scala 3属于研究调查阶段。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Qingfeng</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://gentlebreezeblow.github.io/2022/01/07/scala-01/">https://gentlebreezeblow.github.io/2022/01/07/scala-01/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Qingfeng</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Scala/">
                                    <span class="chip bg-color">Scala</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/11/chisel-01/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="chisel_01">
                        
                        <span class="card-title">chisel_01</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Qingfeng
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Chisel/">
                        <span class="chip bg-color">Chisel</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2022/01/07/scala-01/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Scala学习">
                        
                        <span class="card-title">Scala学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Qingfeng
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Scala/">
                        <span class="chip bg-color">Scala</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">Qingfeng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
